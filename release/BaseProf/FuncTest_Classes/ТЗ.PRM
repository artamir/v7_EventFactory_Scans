//#if !ТАБЛИЦА_ЗНАЧЕНИЙ_ТЗ_ПРМ
//#define ТАБЛИЦА_ЗНАЧЕНИЙ_ТЗ_ПРМ

///<namespace name = "Расширения типа ТаблицаЗначений">

///<class name = "Общие.ТаблицаЗначений"
///descr = "Расширяет функционал типа ТаблицаЗначений"
///use = "ОбщиеМетоды, Общие.Парсер" author = "Диркс Алексей" base = "ТаблицаЗначений">
класс Общие.ТаблицаЗначений = Общие_ТаблицаЗначений.txt : ТаблицаЗначений
{
	///<method name = "ТаблицаЗначений" Тип = "ТаблицаЗначений">
	///<Синтаксис>ТаблицаЗначений()</Синтаксис>
	///<Описание>Возвращает экземпляр базового класса - "ТаблицаЗначения"</Описание>
	///<sig>
	ТаблицаЗначений ТаблицаЗначений();
	///</sig>
	///</method>
	///<method name = "ТЗ" Тип = "ТаблицаЗначений">
	///<Синтаксис>ТЗ()</Синтаксис>
	///<Описание>Возвращает экземпляр базового класса - "ТаблицаЗначения"</Описание>
	///<sig>
	ТаблицаЗначений ТЗ();
	///</sig>
	///</method>
	
	///<method name = "НазначитьТЗ">
	///<Синтаксис>НазначитьТЗ(ТЗ)</Синтаксис>
	///<Описание>Назначает текущему объекту экземпляр базового класса.</Описание>
	///<param name = "ТЗ">ТаблицаЗначений, назначаемая в качестве экземпляра базового класса</param>
	///<sig>
	void НазначитьТЗ(ТаблицаЗначений ТЗ);
	///</sig>
	///</method>
	
	///<method name = "Загрузить">
	///<Синтаксис>Загрузить(ЗагружаемаяТЗ)</Синтаксис>
	///<Описание>Переопределяет стандартный метод, чтобы можно было загружать объекты производных классов.</Описание>
	///<param name = "ЗагружаемаяТЗ">Загружаемая таблица значений.</param>
	///<sig>
	void Загрузить(Неопределенный ЗагружаемаяТЗ);
	///</sig>
	///</method>
	
	///<method name = "ЗагрузитьИзСтроки">
	///<Синтаксис>ЗагрузитьИзСтроки(СтроковоеПредставление)</Синтаксис>
	///<Описание>Загружает состояние объекта из строки, ранее созданной функцией ЗначениеВСтрокуВнутр.</Описание>
	///<param name = "СтроковоеПредставление">Строковое представление объекта, созданное функцией ЗначениеВСтрокуВнутр.</param>
	///<sig>
	void ЗагрузитьИзСтроки(Строка СтроковоеПредставление);
	///</sig>
	///</method>
	
	//_____________________________________________________________________________
	//Информация о колонках. Не следует использовать эти функции там, где критична скорость. 
	//Они раза в 3-4 медленнее, чем ПолучитьПараметрыКолонки().
	// - Колонка - имя или номер колонки. Если не задана, то берется текущая колонка
	
	///<method name = "ЕстьКолонка" Тип = "Число">
	///<Синтаксис>ЕстьКолонка(Колонка)</Синтаксис>
	///<returns type = "Число">Если указанная колонка есть в таблице, то 1. В противном случае - 0.</returns>
	///<param name = "Колонка">Имя или номер колонки</param>
	///<sig>
	Число  ЕстьКолонка(Неопределенный Колонка);
	///</sig>
	///</method>
	
	///<method name = "ИдентификаторКолонки" Тип = "Строка">
	///<Синтаксис>ИдентификаторКолонки([Колонка])</Синтаксис>
	///<returns type = "Строка">Идентификатор указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Строка ИдентификаторКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "ИмяКолонки" Тип = "Строка">
	///<Синтаксис>ИмяКолонки([Колонка])</Синтаксис>
	///<returns type = "Строка">Идентификатор указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Строка ИмяКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "НомерКолонки" Тип = "Число">
	///<Синтаксис>НомерКолонки([Колонка])</Синтаксис>
	///<returns type = "Число">Номер указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Число  НомерКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "ТипКолонки" Тип = "Строка">
	///<Синтаксис>ТипКолонки([Колонка])</Синтаксис>
	///<returns type = "Строка">Тип указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Строка ТипКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "ДлинаКолонки" Тип = "Число">
	///<Синтаксис>ДлинаКолонки([Колонка])</Синтаксис>
	///<returns type = "Число">Длина значения указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Число  ДлинаКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "ТочностьКолонки" Тип = "Число">
	///<Синтаксис>ТочностьКолонки([Колонка])</Синтаксис>
	///<returns type = "Число">Точность значения указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<sig>
	Число  ТочностьКолонки(Неопределенный Колонка = 0);
	///</sig>
	///</method>
	
	///<method name = "ЗаголовокКолонки" Тип = "Строка">
	///<Синтаксис>ЗаголовокКолонки([Колонка = 0], [НовыйЗаголовок])</Синтаксис>
	///<returns type = "Строка">Заголовок указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<param name = "НовыйЗаголовок">Если указан, то заголовок колонки будет изменён.</param>
	///<sig>
	Строка ЗаголовокКолонки(Неопределенный Колонка = 0, Неопределенный НовыйЗаголовок = ПолучитьПустоеЗначение());
	///</sig>
	///</method>
	
	///<method name = "ШиринаКолонки" Тип = "Число">
	///<Синтаксис>ШиринаКолонки([Колонка = 0], [НоваяШирина])</Синтаксис>
	///<returns type = "Число">Ширина указанной колонки</returns>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<param name = "НоваяШирина">Если указан, то ширина колонки будет изменена.</param>
	///<sig>
	Число  ШиринаКолонки(Неопределенный Колонка = 0, Число НоваяШирина = -1);
	///</sig>
	///</method>
	
	
	///<method name = "Структура" Тип = "ТаблицаЗначений">
	///<Синтаксис>Структура()</Синтаксис>
	///<returns type = "ТаблицаЗначений">Таблица значений, описывающая структуру текущего объекта.
	///Структура возвращаемой таблицы:
	/// - Идентификатор - Строка
	///	- Тип           - Строка
	///	- Длина         - Число, 3, 0
	///	- Точность      - Число, 3, 0
	///	- Заголовок     - Строка
	///	- Ширина        - Число, 4, 0
	///</returns>
	///<sig>
	ТаблицаЗначений Структура();
	///</sig>
	///</method>
	//_____________________________________________________________________________
	
	
	///<method name = "УстановитьИдентификаторКолонки" Тип = "Число">
	///<returns type = "Число">1 - в случае удачи, 0 - в случае ошибки.</returns>
	///<Синтаксис>УстановитьИдентификаторКолонки(Колонка, [НовыйИдентификатор], [НовыйНомер])</Синтаксис>
	///<Описание>Изменяет идентификатор и номер указанной колонки.</Описание>
	///<param name = "Колонка">Имя или номер колонки. По умолчанию - текущая колонка.</param>
	///<param name = "НовыйИдентификатор">Новый идентификатор колонки.Если параметр не задан, то идентификатор изменен не будет.</param>
	///<param name = "НовыйНомер">Новый номер колонки.Если параметр не задан, то номер колонки изменен не будет.</param>
	///<sig>
	Число УстановитьИдентификаторКолонки(Неопределенный Колонка, Знач Строка НовыйИдентификатор = "", Знач Число НовыйНомер = 0);
	///</sig>
	///</method>
 
	
	///<method name = "УдалитьКолонки">
	///<Синтаксис>УдалитьКолонки(Колонки)</Синтаксис>
	///<Описание>Удаляет указанные колонки</Описание>
	///<param name = "Колонки">Строка со списком колонок, или список значений</param>
	///<sig>
	void УдалитьКолонки(Знач Неопределенный Колонки);
	///</sig>
	///</method>
	
	///<method name = "Установить">
	///<Синтаксис>Установить([ИмяКолонки], НовоеЗначение)</Синтаксис>
	///<Описание>Аналог УстановитьЗначение(), но записывает всегда в текущую строку (НомерСтроки).</Описание>
	///<param name = "ИмяКолонки">Имя или номер колонки. По умолчанию значение записывается в текущую колонку.</param>
	///<param name = "НовоеЗначение">Записываемое значение</param>
	///<sig>
	void Установить(Знач Неопределенный ИмяКолонки = "", Неопределенный НовоеЗначение);
	///</sig>
	///</method>
	
	///<method name = "Получить">
	///<Синтаксис>Получить([ИмяКолонки])</Синтаксис>
	///<returns type = "Неопределенный">Значение из указанной колонки</returns>
	///<Описание>Аналог ПолучитьЗначение(), но считывает всегда из текущей строки (НомерСтроки).</Описание>
	///<param name = "ИмяКолонки">Имя или номер колонки. По умолчанию значение считывается из текущей колонки.</param>
	///<sig>
	Неопределенный Получить(Знач Неопределенный ИмяКолонки = "");
	///</sig>
	///</method>
	
	///<method name = "Копия" Тип = "Общие.ТаблицаЗначений">
	///<Синтаксис>Копия([Колонки])</Синтаксис>
	///<returns type = "Общие.ТаблицаЗначений">Создает дубликат текущего объекта</returns>
	///<param name = "Колонки" type = "Строка">Если задан, то будут скопированы только указанные колонки.</param>
	///<sig>
	Общие.ТаблицаЗначений Копия(Строка Колонки = "");
	///</sig>
	///</method>
	
	///<method name = "КопияСтруктуры" Тип = "Общие.ТаблицаЗначений">
	///<Синтаксис>КопияСтруктуры()</Синтаксис>
	///<returns type = "Общие.ТаблицаЗначений">Возвращает пустую таблицу, структура которой полностью совпадает со структурой текущего объекта.</returns>
	///<sig>
	Общие.ТаблицаЗначений КопияСтруктуры();
	///</sig>
	///</method>
	
	///<method name = "ЗагрузитьСтруктуру">
	///<Синтаксис>ЗагрузитьСтруктуру(ИсходнаяТЗ, [НеУдалятьТекщую = 0])</Синтаксис>
	///<Описание>Изменяет сруктуру текущего объект в соответствии со структурой таблицы ИсходнаяТЗ.</Описание>
	///<param name = "ИсходнаяТЗ">Таблица, структуру которой нужно скопировать.</param>
	///<param name = "НеУдалятьТекщую">Если 1, то текущая структура сохраняется, добавляются только новые колонки из копируемой ТЗ. Параметры совпадающих колонок приводятся в соответствие.</param>
	///<sig>
	void ЗагрузитьСтруктуру(Неопределенный ИсходнаяТЗ, Число НеУдалятьТекщую = 0);
	///</sig>
	///</method>
	
	///<method name = "КопироватьСтроку">
	///<Синтаксис>КопироватьСтроку(Откуда, [нСтрОткуда = 0], [ПоИменамКолонок = 1])</Синтаксис>
	///<Описание>Копирует значения колонок из ТЗ Откуда в текущую строку ТЗ.</Описание>
	///<param name = "Откуда">Таблица значений, из которой копируется строка. Если не задана, то копируется строка текущей таблицы.</param>
	///<param name = "нСтрОткуда">Номер копируемой строки. Если не задан (0), то копируется текущая строка таблицы Откуда.</param>
	///<param name = "ПоИменамКолонок">Если 1, то колонки сопоставляются по идентификаторам, если 0 - по номерам. По умолчанию - 0.</param>
	///<sig>
	void КопироватьСтроку(Неопределенный Откуда = "", Знач Число нСтрОткуда=0, Число ПоИменамКолонок=0);
	///</sig>
	///</method>
	
	///<method name = "Объединить">
	///<Синтаксис>Объединить(Откуда, [НачСтрока], [КонСтрока], [ПоИменамКолонок])</Синтаксис>
	///<Описание>В таблицу добавляются указанные строки из таблицы Откуда</Описание>
	///<param name = "Откуда">Добавляемая таблица</param>
	///<param name = "НачСтрока">Номер первой добавляемой строки. Если не задан, то с первой строки.</param>
	///<param name = "КонСтрока">Номер последней добавляемой строки. Если не задан, то до последней строки.</param>
	///<param name = "ПоИменамКолонок">Если 1, то колонки сопоставляются по идентификаторам, если 0 - по номерам. По умолчанию - 0.</param>
	///<sig>
	void Объединить(Неопределенный Откуда, Знач Число НачСтрока=0, Знач Число КонСтрока=0, Число ПоИменамКолонок=1);
	///</sig>
	///</method>
	
	///<method name = "Запись" Тип = "Число">
	///<Синтаксис>Запись(ЗначениеКолонки1, ЗначениеКолонки2, ..., ЗначениеКолонкиN)</Синтаксис>
	///<Описание>Создает новую строку в ТЗ, и записывает туда переданные значения.</Описание>
	///<returns type = "Число">Номер добавленной строки</returns>
	///<sig>
	Число Запись(...);
	///</sig>
	///</method>
	
	///<method name = "Фильтр">
	///<Синтаксис>Фильтр(ИмяКолонки1, Знач1_1, Знач1_2, ИмяКолонки2, Знач2_1, Знач2_2, ... ИмяКолонкиN, ЗначN_1, ЗначN_2)</Синтаксис>
	///<Описание>Удаляет все строки ТЗ, которые не соответствуют условию фильтра. Условий может быть несколько. Каждое задается тремя параметрами: ИмяКолонки, Знач1, Знач2. Все три параметра условия обязательны. Условие проверяется с помощю метода ОбщиеМетоды.ФильтрЗначения().</Описание>
	///<sig>
	void Фильтр(...);
	///</sig>
	///</method>

	///<method name = "НайтиСтроку" Тип = "Число">
	///<Синтаксис>НайтиСтроку(КолонкаПоиска, ЗначениеПоиска, [Позиционироваться = 1])</Синтаксис>
	///<Описание>Находит строку ТЗ по указанной колонке и её значению.</Описание>
	///<returns type = "Число">Если параметр Позиционироваться = 1, то возвращает 1, если строка найдена и 0 если не найдена. Если параметр Позиционироваться = 1, то возвращает номер найденной строки или 0.</returns>
	///<param name = "КолонкаПоиска">Идентификатор колонки, в которой нужно искать значение</param>
	///<param name = "ЗначениеПоиска">Искомое значение</param>
	///<param name = "Позиционироваться">1 - таблица будет спозиционирована на найденной строке; 0 - таблица не перепозиционируется.</param>
	///<sig>
	Число НайтиСтроку(Строка КолонкаПоиска, Неопределенный ЗначениеПоиска, Число Позиционироваться=1);
	///</sig>
	///</method>
	
	///<method name = "НайтиПоКлючу" Тип = "Число">
	///<Синтаксис>НайтиПоКлючу(Ключ, [НачСтрока], [Позиционироваться])</Синтаксис>
	///<Описание>Находит строку по заданным колонкам и их значениям.</Описание>
	///<returns type = "Число">Если Позиционироваться = 0, то номер найденной строки, если Позиционироваться = 1, то 1. Если ничего не найдено, то 0.</returns>
	///<param name = "Ключ">Список колонок и значений поиска. Ключ заполняется так: 
	///Ключ.Установить(ИмяКолонки, Значение);
	///или так: 
	///Ключ.ДобавитьЗначение(Значение, ИмяКолонки);
	///</param>
	///<param name = "НачСтрока">Начальная строка поиска. Если не задан, то поиск производится начиная с первой строки таблицы.</param>
	///<param name = "Позиционироваться">Определяет, будет ли в случае удачного поиска перепозиционорован курсор в ТЗ.</param>
	///<sig>
	Число НайтиПоКлючу(СписокЗначений Ключ, Число НачСтрока=0, Число Позиционироваться=1);
	///</sig>
	///</method>

	///<method name = "НайтиПоКлючу2" Тип = "Число">
	///<Синтаксис>НайтиПоКлючу2(Ключ, [ПоВнутрПредставлению], [НачСтрока], [КонСтрока], [ИскатьПоследнюю], [Позиционироваться])</Синтаксис>
	///<Описание>Бинарный алгоритм поиска строки таблицы по ключу. Таблица должна быть предварительно отсортирована по колонкам ключа.</Описание>
	///<returns type = "Число">Если Позиционироваться = 0, то номер найденной строки, если Позиционироваться = 1, то 1. Если ничего не найдено, то 0.</returns>
	///<param name = "Ключ" type = "СписокЗначений">Список колонок и значений поиска. Ключ заполняется так: 
	///Ключ.Установить(ИмяКолонки, Значение);
	///или так: 
	///Ключ.ДобавитьЗначение(Значение, ИмяКолонки);
	///</param>
	///<param name = "ПоВнутрПредставлению" type = "Число">Если 1, то при сравнении используется внутреннее представление объекта (ЗначениеВСтрокуВнутр). Это нужно в тех случаях, когда есть разные объекты с одинаковым представлением (например, разные контрагенты с одинаковым наименованием). Естественно, сортировать ТЗ также нужно по внутр. представлениям (см. СортроватьПоКлючу()).</param>
	///<param name = "НачСтрока">Начальная строка поиска. Если не задан, то поиск производится начиная с первой строки таблицы.</param>
	///<param name = "Позиционироваться">Определяет, будет ли в случае удачного поиска перепозиционорован курсор в ТЗ.</param>
	///<sig>
	Число НайтиПоКлючу2(СписокЗначений Ключ, Число ПоВнутрПредставлению = 0, 
						Число НачСтрока = 0, Число КонСтрока = 0, 
						Число ИскатьПоследнюю = 0, Число Позиционироваться = 1);
	///</sig>
	///</method>
	
	///<method name = "Ключ" Тип = "СписокЗначений">
	///<Синтаксис>Ключ([Колонка1, Значение1] [, Колонка2, Значение2] ...)</Синтаксис>
	///<Описание>Вспомогательная функция для конструирования ключа.</Описание>
	///<param name = ""></param>
	///<sig>
	СписокЗначений Ключ(...);
	///</sig>
	///</method>
	
	///<method name = "СортироватьПоКлючу">
	///<Синтаксис>СортироватьПоКлючу(Ключ, [ПоВнутрПредставлению])</Синтаксис>
	///<Описание>Сорирует таблицу по колонкам из указанного ключа.</Описание>
	///<param name = "Ключ" type = "СписокЗначений">Ключ поиска, из которого будут взяты колонки для сортировки.</param>
	///<param name = "ПоВнутрПредставлению" type = "Число">1 - таблица будет отсортирована по внутренним представлениям объектов.</param>
	///<sig>
	void СортироватьПоКлючу(СписокЗначений Ключ, Число ПоВнутрПредставлению = 0);
	///</sig>
	///</method>
	
	///<method name = "qsort">
	///<Синтаксис>qsort(CompMod)</Синтаксис>
	///<Описание>Данный метод является практически полной калькой с функции qsort из Standard C Library</Описание>
	///<param name = "CompMod" type = "ВыполняемыйМодуль">объект типа ВыполняемыйМодуль, в котором задана функция сравнения двух строк ТЗ.
    ///Ф-ция должна называться Compare, и иметь 3 параметра:
    ///   - ТЗ - таблица значений, строки которой сравниваются
    ///   - н1, н2 - Число, номера сравниваемых строк
    ///Ф-ция должна возвращать 0, если строки равны; -1 если строка н1 меньше строки н2; 1 если строка н1 больше строки н2</param>
	///<sig>
	void qsort(ВыполняемыйМодуль CompMod);
	///</sig>
	///</method>

	///<method name = "НайтиИПолучить">
	///<Синтаксис>НайтиИПолучить(КолонкаПоиска, ЗначПоиска, ВозвращаемаяКолонка)</Синтаксис>
	///<Описание>Находит строку по условию КолонкаПоиска = ЗначПоиска, и возвращает значение колонки ВозвращаемаяКолонка. Если строка не найдена, то возвращает пустое значение того же типа, что и колонка ВозвращаемаяКолонка. Таблица не перепозиционируется.</Описание>
	///<returns type = "Неопределенный">Значение указанной колонки из найденной строки.</returns>
	///<param name = "КолонкаПоиска">Идентификатор или номер колонки.</param>
	///<param name = "ЗначПоиска">Значение, которое нужно искать.</param>
	///<param name = "ВозвращаемаяКолонка">Идентификатор колонки, значение которой будет возвращено.</param>
	///<sig>
	Неопределенный НайтиИПолучить(Неопределенный КолонкаПоиска, Неопределенный ЗначПоиска, Строка ВозвращаемаяКолонка);
	///</sig>
	///</method>

	///<method name = "СледующееЗначение" Тип = "Число">
	///<Синтаксис>СледующееЗначение(Колонка, ТипПоиска, Направление)</Синтаксис>
	///<Описание>Находит в ТЗ следующую строку, отличную или совпадающую с текущей.</Описание>
	///<returns type = "Число">Номер найденной строки, или 0.</returns>
	///<param name = "Колонка">имя колонки, значения которой нужно анализировать. Если колонка не задана, то берётся текущая.</param>
	///<param name = "ТипПоиска">1 - искать такое же, 2 - искать отличное, 3 - искать пустое, 4 - искать не пустое. По умолчанию 1.</param>
	///<param name = "Направление">1 - вниз, -1 - вверх. По умолчанию - 1</param>
	///<sig>
	Число СледующееЗначение(Знач Строка Колонка = "", Число ТипПоиска = 1, Число Направление = 1);
	///</sig>
	///</method>
	
	///<method name = "Суммировать">
	///<Синтаксис>Суммировать(Слагаемое, СпособСуммирования, Колонки)</Синтаксис>
	///<Описание>Построчное суммирование ТЗ: Приемник = Приемник + Слагаемое. Если колонки из Слагаемое отсутствуют в ТЗ Приемник, то они добавляются.</Описание>
	///<param name = "Способ">способ суммирования: 0 - все строки; 1 - только текущие строки; 2 - все строки Слагаемого в текущую строку Приемника.</param>
	///<param name = "Колонки">строка или список значений с суммируемыми колонками (если это строка, то колонки перечисляются через запятую). Если колонки не указаны, то суммируются все числовые колонки из Слагаемое.</param>
	///<sig>
	void Суммировать(Неопределенный Слагаемое, Число СпособСуммирования = 0, Неопределенный Колонки = ПолучитьПустоеЗначение());
	///</sig>
	///</method>
		
	///<method name = "ИтогПоСтроке" Тип = "">
	///<Синтаксис>ИтогПоСтроке(НомерСтроки, Колонки)</Синтаксис>
	///<returns type = "Число">Сумма по указанным колонкам.</returns>
	///<param name = "НомерСтроки">номер строки, по которой считать сумму. Если параметр опущен, то считается итог по текущей строке. Если НомерСтроки = 0, то считается итог по всей таблице.</param>
	///<param name = "Колонки">строка или список значений с суммируемыми колонками (если это строка, то колонки перечисляются через запятую). Если колонки не указаны, то суммируются все числовые колонки. Если список колонок задается строкой, то они перечисляются через запятую. Перед идентификатором колонки может стоять знак "-" - тогда значение колонки будет вычитаться из суммы.</param>
	///<sig>
	Неопределенный ИтогПоСтроке(Знач Неопределенный НомерСтроки  = ПолучитьПустоеЗначение(), Знач Неопределенный Колонки = ПолучитьПустоеЗначение());
	///</sig>
	///</method>

	
	///<method name = "ExportToExcel">
	///<Синтаксис>ExportToExcel([Excel], [ColList], [FirstRow], [LastRow], [ToFreezePanes = 0], [AutoFilter = 0])</Синтаксис>
	///<Описание>Выгружает ТЗ в Excel.</Описание>
	///<param name = "Excel">OLE-объект Excel.Application. Если не задан, то метод сам создает для себя такой объект.</param>
	///<param name = "ColList">строка или список значений с выгружаемыми колонками (если это строка, то колонки перечисляются через запятую).</param>
	///<param name = "FirstRow">Первая выгружаемая строка. По умолчанию - 1.</param>
	///<param name = "LastRow">Последняя выгружаемая строка. По умолчанию - последняя строка таблицы.</param>
	///<param name = "ToFreezePanes">Если 1, то строка заголовков колонок будет закреплена при просмотре (эффект такой же, как если в Excel нажать Окно/Закрепить области).</param>
	///<param name = "AutoFilter">Если 1, то будет включен автофильтр (Данные/Фильтр/Автофильтр).</param>
	///<sig>
	undefine ExportToExcel(val undefine Excel = "",
						   val undefine ColList = "", val undefine FirstRow = 0, val undefine LastRow = 0, 
						   number ToFreezePanes = 0, number AutoFilter = 0);
	///</sig>
	///</method>
	
	///<method name = "ЗаписатьВФайл" Тип = "Число">
	///<Синтаксис>ЗаписатьВФайл(ИмяФайла, [ФорматФайла])</Синтаксис>
	///<Описание>Записывает ТЗ в файл. При наличии внешней компоненты V7PLUS.DLL для формирования текстового файла используется объект AddIn.V7TextFile. При выгрузке больших таблиц это дает заметный выигрыш в скорости. Если ВК отсутствует, то используется стандартный объект Текст.</Описание>
	///<returns type = "Число">1 - функция выполнена успешно; 0 - функция не выполнена.</returns>
	///<param name = "ИмяФайла">имя файла, куда записывать ТЗ</param>
	///<param name = "ФорматФайла">1 - стандартный метод ЗначениеВФайл(ИмяФайла, ТЗ, 1);
	///2 - стандартный метод ЗначениеВФайл(ИмяФайла, ТЗ, 2);
	///3 - альтернативный формат записи - объём файла уменьшается в несколько раз.</param>
	///<sig>
	Число ЗаписатьВФайл(Строка ИмяФайла, Число ФорматФайла = 3);
	///</sig>
	///</method>
	
	///<method name = "СчитатьИзФайла" Тип = "Число">
	///<Синтаксис>СчитатьИзФайла(ИмяФайла, ФорматФайла)</Синтаксис>
	///<Описание>Считывает ТЗ из файла.</Описание>
	///<returns type = "Число">1 - функция выполнена успешно; 0 - функция не выполнена.</returns>
	///<param name = "ИмяФайла">имя файла, откуда читать ТЗ.</param>
	///<param name = "ФорматФайла">тот же, что и при записи. Если указать 0, то функция попытается сама определить формат.</param>
	///<sig>
	Число СчитатьИзФайла(Строка ИмяФайла, Число ФорматФайла = 0);
	///</sig>
	///</method>
};
///</class>

///</namespace>

//#endif