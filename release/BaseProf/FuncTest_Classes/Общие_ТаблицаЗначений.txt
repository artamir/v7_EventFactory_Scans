
Процедура ЗаписатьТЗВФайлРекурсия(ТЗ, Файл, Прогресс=1) Далее
Функция СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки=1, _Стр_=0) Далее


Функция Конт(Конт) Возврат Конт; КонецФункции 


//_____________________________________________________________________________
Функция КлассСохраняемый()
	Возврат 1;
КонецФункции
//_____________________________________________________________________________
Функция СохранитьКлассВСтроку()
	Возврат ЗначениеВСтрокуВнутр(Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений"));
КонецФункции
//_____________________________________________________________________________
Процедура ЗагрузитьИзСтроки(Стр) Экспорт
	Перем ТЗ;
	ТЗ = ЗначениеИзСтрокиВнутр(Стр);
	Если ТипЗначенияСтр(ТЗ) = "ТаблицаЗначений" Тогда
		Конт(Контекст).ЗаменитьЭксзБазовогоКласса("ТаблицаЗначений", ТЗ);
	КонецЕсли;
КонецПроцедуры

//_____________________________________________________________________________
// Преобразование к базовому типу
Функция ТЗ() Экспорт
	Возврат Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
КонецФункции
Функция ТаблицаЗначений()
	Возврат Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
КонецФункции

//_____________________________________________________________________________
Процедура НазначитьТЗ(ТЗ) Экспорт
	Конт = Конт(Контекст);
	Конт.ЗаменитьЭксзБазовогоКласса("ТаблицаЗначений", ТЗ);
КонецПроцедуры

//_____________________________________________________________________________
Процедура Загрузить(ЗагружаемаяТЗ) Экспорт
	Перем ТЗ;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Если ТипЗначенияСтр(ЗагружаемаяТЗ) = "ТаблицаЗначений" Тогда
		ТЗ.Загрузить(ЗагружаемаяТЗ);
	Иначе
		Попытка
			ТЗ.Загрузить(ЗагружаемаяТЗ.ТЗ());
		Исключение
			Сообщить("Невозможно загрузить объект типа '" + ТипЗначенияСтр(ЗагружаемаяТЗ) + "'");
		КонецПопытки;
	КонецЕсли;
	
	Попытка
		ТЗ.ПолучитьСтрокуПоНомеру(ЗагружаемаяТЗ.НомерСтроки);
		ТЗ.ТекущаяСтрока(ЗагружаемаяТЗ.НомерСтроки);
	Исключение
	КонецПопытки;
КонецПроцедуры


//_____________________________________________________________________________
Функция ЕстьКолонка(ИмяКолонки) Экспорт
	Попытка
		Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений").ПолучитьПараметрыКолонки(ИмяКолонки);
	Исключение
		Возврат 0;
	КонецПопытки;
	Возврат 1;
КонецФункции


//_____________________________________________________________________________
Функция ИдентификаторКолонки(Знач Колонка) Экспорт
	Перем ТЗ;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");

	Если ПустоеЗначение(Колонка) = 1 Тогда
		Попытка
			Возврат ТЗ.ТекущаяКолонка();
		Исключение
			Возврат "";
		КонецПопытки;
	КонецЕсли;
	
	Если ТипЗначения(Колонка) = 1 Тогда
		Возврат ТЗ.ПолучитьПараметрыКолонки(Колонка);
	Иначе
		Колонка = ТЗ.ПолучитьПараметрыКолонки(Строка(Колонка));
		Возврат ТЗ.ПолучитьПараметрыКолонки(Колонка);
	КонецЕсли;
КонецФункции

Функция ИмяКолонки(Колонка) Экспорт
	Возврат ИдентификаторКолонки(Колонка);
КонецФункции

//_____________________________________________________________________________
Функция НомерКолонки(Знач Колонка) Экспорт
	Перем ТЗ;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");

	Если ПустоеЗначение(Колонка) = 1 Тогда
		Попытка
			Колонка = ТЗ.ТекущаяКолонка();
		Исключение
			Возврат "";
		КонецПопытки;
	КонецЕсли;
	
	Если ТипЗначения(Колонка) = 1 Тогда
		Колонка = ТЗ.ПолучитьПараметрыКолонки(Колонка);
	ИначеЕсли ТипЗначения(Колонка) = 2 Тогда
	Иначе
		Колонка = Строка(Колонка);
	КонецЕсли;

	Попытка
		Возврат ТЗ.ПолучитьПараметрыКолонки(ТЗ.ТекущаяКолонка());
	Исключение
		Возврат 0;
	КонецПопытки;
КонецФункции

//_____________________________________________________________________________
Функция ТипКолонки(Знач Колонка) Экспорт
	Перем ТЗ, Тип;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(Колонка) = 1 Тогда Колонка = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат "";
	КонецПопытки;
	
	ТЗ.ПолучитьПараметрыКолонки(Колонка, Тип);
	Возврат Тип;
КонецФункции

Функция ДлинаКолонки(Колонка) Экспорт
	Перем ТЗ, Длина;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(Колонка) = 1 Тогда Колонка = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат 0;
	КонецПопытки;
	
	ТЗ.ПолучитьПараметрыКолонки(Колонка,, Длина);
	Возврат Длина;
КонецФункции

Функция ТочностьКолонки(Колонка) Экспорт
	Перем ТЗ, Точность;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(Колонка) = 1 Тогда Колонка = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат 0;
	КонецПопытки;
	
	ТЗ.ПолучитьПараметрыКолонки(Колонка,,, Точность);
	Возврат Точность;
КонецФункции

Функция ЗаголовокКолонки(Колонка, НовыйЗаголовок) Экспорт
	Перем ТЗ, Заголовок;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(Колонка) = 1 Тогда Колонка = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат "";
	КонецПопытки;
	
	ТЗ.ПолучитьПараметрыКолонки(Колонка,,,, Заголовок);
	Если ТипЗначения(Заголовок) = 2 Тогда
		ТЗ.УстановитьПараметрыКолонки(Колонка,,,, НовыйЗаголовок);
	КонецЕсли;
	Возврат Заголовок;
КонецФункции

Функция ШиринаКолонки(Колонка, НоваяШирина) Экспорт
	Перем ТЗ, Ширина;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(Колонка) = 1 Тогда Колонка = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат 0;
	КонецПопытки;
	
	ТЗ.ПолучитьПараметрыКолонки(Колонка,,,,, Ширина);
	
	Если НоваяШирина > 0 Тогда
		ТЗ.УстановитьПараметрыКолонки(Колонка,,,,, НоваяШирина);
	КонецЕсли;
	
	Возврат Ширина;
КонецФункции


//_____________________________________________________________________________
Функция Структура() Экспорт
	Перем ТЗ, Структура;
	Перем Идентификатор, Тип, Длина, Точность, Заголовок, Ширина;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");

	Структура = СоздатьОбъект("ТаблицаЗначений");
	Структура.НоваяКолонка("Идентификатор", "Строка");
	Структура.НоваяКолонка("Тип", "Строка");
	Структура.НоваяКолонка("Длина", "Число", 3, 0);
	Структура.НоваяКолонка("Точность", "Число", 3, 0);
	Структура.НоваяКолонка("Заголовок", "Строка");
	Структура.НоваяКолонка("Ширина", "Число", 4, 0);
	
	Для н=1 По ТЗ.КоличествоКолонок() Цикл
		Структура.НоваяСтрока();
		Идентификатор = ТЗ.ПолучитьПараметрыКолонки(н, Тип, Длина, Точность, Заголовок, Ширина);
		Структура.Идентификатор = Идентификатор;
		Структура.Тип = Тип;
		Структура.Длина = Длина;
		Структура.Точность = Точность;
		Структура.Заголовок = Заголовок;
		Структура.Ширина = Ширина;
	КонецЦикла;
	
	Возврат Структура;
КонецФункции

//_____________________________________________________________________________
Функция УстановитьИдентификаторКолонки(Колонка, Знач НовыйИдентификатор, Знач НовыйНомер) Экспорт
	Перем ТЗ;
	Перем Идентификатор, НомерКолонки, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение;
	Перем тзКолонка;
	
	НомерКолонки = НомерКолонки(Колонка);
	Если НомерКолонки = 0 Тогда
		//#error Неверно указана колонка
		Возврат 0;
	КонецЕсли;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Идентификатор = ТЗ.ПолучитьПараметрыКолонки(НомерКолонки, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение);
	
	
	Если НовыйИдентификатор = Идентификатор Тогда
		НовыйИдентификатор = Идентификатор;
	ИначеЕсли ПустаяСтрока(НовыйИдентификатор) = 1 Тогда
		НовыйИдентификатор = Идентификатор;
	Иначе
		Если ЕстьКолонка(НовыйИдентификатор) = 1 Тогда
			Возврат 0;
		КонецЕсли;
	КонецЕсли;

	Если НовыйНомер = НомерКолонки Тогда
		НовыйНомер = НомерКолонки;
	ИначеЕсли НовыйНомер = 0 Тогда
		НовыйНомер = НомерКолонки;
	Иначе
		Если НовыйНомер > ТЗ.КоличествоКолонок() Тогда
			Возврат 0;
		КонецЕсли;
	КонецЕсли;
	
	тзКолонка = СоздатьОбъект("ТаблицаЗначений");
	ТЗ.Выгрузить(тзКолонка,,, НомерКолонки);
	ТЗ.УдалитьКолонку(НомерКолонки);
	ТЗ.ВставитьКолонку(НовыйИдентификатор, НовыйНомер, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение);
	ТЗ.Заполнить(тзКолонка,,, НовыйНомер);
	
	Возврат 1;
КонецФункции


//_____________________________________________________________________________
Процедура УдалитьКолонки(Знач Колонки) Экспорт
	Перем Методы, н, Колонка;
	
	Если ТипЗначения(Колонки) = 2 Тогда
		Методы = СоздатьОбъект("ОбщиеМетоды");
		Колонки = СтрЗаменить(Колонки, " ", "");
		Колонки = Методы.СтрокуВСписок(Колонки, ",");
	КонецЕсли;
	
	ТЗ = Конт(Контекст);
	Для н = 1 По Колонки.РазмерСписка() Цикл
		Колонка = Колонки.ПолучитьЗначение(н);
		Попытка
			ТЗ.УдалитьКолонку(Колонка);
		Исключение
		КонецПопытки;
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
Процедура Установить(Знач ИмяКолонки = "", НовоеЗначение) Экспорт
	Перем ТЗ;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(ИмяКолонки) = 1 Тогда ИмяКолонки = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат;
	КонецПопытки;
	
	ТЗ.УстановитьЗначение(ТЗ.НомерСтроки, ИмяКолонки, НовоеЗначение);
КонецПроцедуры

//_____________________________________________________________________________
Функция Получить(Знач ИмяКолонки = "") Экспорт
	Перем ТЗ;

	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Попытка
		Если ПустоеЗначение(ИмяКолонки) = 1 Тогда ИмяКолонки = ТЗ.ТекущаяКолонка(); КонецЕсли;
	Исключение
		Возврат ПолучитьПустоеЗначение();
	КонецПопытки;
	
	Возврат ТЗ.ПолучитьЗначение(ТЗ.НомерСтроки, ИмяКолонки);
КонецФункции


//_____________________________________________________________________________
Функция Копия(Колонки) Экспорт
	Перем ТЗ;
	
	тзСам = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	ТЗ = СоздатьОбъект("Общие.ТаблицаЗначений");
	тзСам.Выгрузить(ТЗ.ТЗ(),,, Колонки);
	
	Возврат ТЗ;
КонецФункции

//_____________________________________________________________________________
//Создает и возвращает ТЗ с такой же структурой, как <Откуда>
Функция КопияСтруктуры() Экспорт
	Перем Откуда;
	Перем н, ТЗ;
	Перем Колонка, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение;
	
	Откуда = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	ТЗ = СоздатьОбъект("Общие.ТаблицаЗначений");
	Для н=1 По Откуда.КоличествоКолонок() Цикл
		Колонка = Откуда.ПолучитьПараметрыКолонки(н, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
		ТЗ.НоваяКолонка(Колонка, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
	КонецЦикла;
	
	Возврат ТЗ;
КонецФункции

//_____________________________________________________________________________
Процедура ЗагрузитьСтруктуру(ИсхТЗ, НеУдалятьТекщую) Экспорт
	Перем Конт, ТЗ, н;
	Перем Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение;
	
	Конт = Конт(Контекст);
	ТЗ = Конт.ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Если НеУдалятьТекщую = 0 Тогда
		н = ТЗ.КоличествоКолонок();
		Пока н > 0 Цикл
			ТЗ.УдалитьКолонку(н);
			н = н - 1;
		КонецЦикла;
	КонецЕсли;
	
	Для н=1 По ИсхТЗ.КоличествоКолонок() Цикл
		Колонка = ИсхТЗ.ПолучитьПараметрыКолонки(н, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
		Если Конт.ЕстьКолонка(Колонка) = 1 Тогда
			ТЗ.УстановитьПараметрыКолонки(Колонка, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
		Иначе
			ТЗ.НоваяКолонка(Колонка, Тип, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
//Копирует значения колонок из ТЗ <Откуда> в текущую строку ТЗ.
//Колонки сопоставляются в зависимости от флага <ПоИменамКолонок>
Процедура КопироватьСтроку(_Откуда_, Знач нСтрОткуда = 0, ПоИменамКолонок = 0) Экспорт
	Перем Откуда, Куда;
	Перем н, Зн;
	Перем ИмяКолонки;
	
	Куда = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Если ПустоеЗначение(_Откуда_) = 1 Тогда
		Откуда = Куда; //Копируем из себя в себя же
	Иначе
		Откуда = _Откуда_;
	КонецЕсли;
	
	Если нСтрОткуда = 0 Тогда
		нСтрОткуда = Откуда.НомерСтроки;
	КонецЕсли;
	
	Если Куда.КоличествоСтрок() = 0 Тогда
		Куда.НоваяСтрока();
	КонецЕсли;
	
	Если ПоИменамКолонок = 1 Тогда
		МаксН = Откуда.КоличествоКолонок();
	Иначе
		МаксН = Мин(Откуда.КоличествоКолонок(), Куда.КоличествоКолонок());
	КонецЕсли;
	Для н=1 По МаксН Цикл
		Зн = Откуда.ПолучитьЗначение(нСтрОткуда, н);
		Если ПоИменамКолонок=1 Тогда
			ИмяКолонки = Откуда.ПолучитьПараметрыКолонки(н);
			Попытка
				Куда.УстановитьЗначение(Куда.НомерСтроки, ИмяКолонки, Зн);
			Исключение
			КонецПопытки;
		Иначе
			Куда.УстановитьЗначение(Куда.НомерСтроки, н, Зн);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
//В ТЗ добавляются строки из ТЗ <Откуда>
Процедура Объединить(Откуда, Знач н1=0, Знач н2=0, ПоИменамКолонок=0) Экспорт
	Перем Куда;
	Перем н;
	
	Куда = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Если (н1 = 0) И (н2 = 0) И (ПоИменамКолонок = 0) И (ПустоеЗначение(Откуда) = 0) Тогда
		Если Откуда.КоличествоСтрок() = 0 Тогда Возврат; КонецЕсли;
		
		н1 = Куда.КоличествоСтрок() + 1;
		Куда.КоличествоСтрок(Куда.КоличествоСтрок() + Откуда.КоличествоСтрок());
		н2 = Куда.КоличествоСтрок();
		Куда.Заполнить(Откуда, н1, н2);
	КонецЕсли;

	Если Н1 = 0 Тогда Н1 = 1; КонецЕсли;
	Если Н2 = 0 Тогда Н2 = Откуда.КоличествоСтрок(); КонецЕсли;
	
	Для н = Н1 По Н2 Цикл
		Куда.НоваяСтрока();
		КопироватьСтроку(Откуда, н, ПоИменамКолонок);
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
//Создает новую строку в ТЗ, и записывает туда переданные значения
Функция Запись() Экспорт
	Перем СпПарам;
	Перем н, МаксН, ТЗ;
	
	СпПарам = Конт(Контекст).ПолучитьСписокПараметров("Запись");
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	ТЗ.НоваяСтрока();
	МаксН = Мин(ТЗ.КоличествоКолонок(), СпПарам.РазмерСписка());
	Для н=1 По МаксН Цикл
		ТЗ.УстановитьЗначение(ТЗ.НомерСтроки, н, СпПарам.ПолучитьЗначение(н));
	КонецЦикла;
	
	Возврат ТЗ.НомерСтроки;
КонецФункции

//_____________________________________________________________________________
Функция ПараметрыИзСписка(СпПарам, НомерПервого, КоличествоПараметров, З1="", З2="", З3="", З4="")
	Если НомерПервого > СпПарам.РазмерСписка() Тогда
		Возврат 0;
	КонецЕсли;
	
	Для н=1 По КоличествоПараметров Цикл
		Попытка
			Значение = СпПарам.ПолучитьЗначение(НомерПервого+н-1);
		Исключение
			Значение = ПолучитьПустоеЗначение();
		КонецПопытки;
		//#if DEBUG
		Сообщить("н = "+н+"; знач - '"+Значение+"'  - "+ТипЗначенияСтр(Значение));
		//#endif
		Если н=1 Тогда
			З1 = Значение;
		ИначеЕсли н=2 Тогда
			З2 = Значение;
		ИначеЕсли н=3 Тогда
			З3 = Значение;
		ИначеЕсли н=4 Тогда
			З4 = Значение;
		КонецЕсли;
	КонецЦикла;
	
	НомерПервого = НомерПервого + КоличествоПараметров;
	
	Возврат 1;
КонецФункции

//_____________________________________________________________________________
//Удаляет все строки ТЗ, которые не соответствуют условию фильтра.
//Условий может быть несколько. Каждое задается тремя параметрами: <ИмяКолонки>, <Знач1>, <Знач2>. Все три параметра обязательны.
//Условие задается как <Знач1> <= <ИмяКолонки> <= <Знач2>
Процедура Фильтр() Экспорт
	Перем н, ТЗ, Значение;
	Перем СпПарам, н_парам, ИмяКолонки, Знач1, Знач2;

	Конт = Конт(Контекст);
	СпПарам = Конт.ПолучитьСписокПараметров("Фильтр");
	ТЗ = Конт.ПолучитьБазовыйКласс("ТаблицаЗначений");
	ОбщМетоды = СоздатьОбъект("ОбщиеМетоды");
	
	н = ТЗ.КоличествоСтрок();
	Пока н>0 Цикл
		н_парам = 1;
		Пока ПараметрыИзСписка(СпПарам, н_парам, 3, ИмяКолонки, Знач1, Знач2) = 1 Цикл
			//#if DEBUG
			Сообщить(""+ИмяКолонки+" от "+Знач1+" до "+Знач2);
			//#endif
			Значение = ТЗ.ПолучитьЗначение(н, ИмяКолонки);
			Если ОбщМетоды.ФильтрЗначения(Значение, Знач1, Знач2) = 0 Тогда
				ТЗ.УдалитьСтроку(н);
				Прервать; //Прерываем цикл по параметрам
			КонецЕсли;
		КонецЦикла;
		
	    н = н - 1;
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
//Находит строку ТЗ по указанным колонкам и их значениям
//Параметры:
//	Ключ - СписокЗначений. Список идентификаторов колонок и искомых значений.
//         Заполняется так: Ключ.Установить(ИмяКолонки, Значение);
//                 или так: Ключ.ДобавитьЗначение(Значение, ИмяКолонки);
//	       Значение м.б. СписокЗначений или ТаблицаЗначений.
//	НачСтрока - Число. Если указана, то поиск начинается с этой строки
//	Позиционироваться - Число. Если 1, то ТЗ будет спозиционирована на найденной строке
//Возвращаемое значение:
//    1) Позиционироваться = 1:   строка найдена - 1; не найдена - 0
//    2) Позиционироваться = 0:   строка найдена - номер строки; не найдена - 0
Функция НайтиПоКлючу(Ключ, НачСтрока=0, Позиционироваться=1) Экспорт
    Перем ТЗ;
	Перем н, нк;
	Перем ЗначПоиска, ЗначТЗ, КолонкаПоиска, Найдено;

	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Если ТЗ.КоличествоСтрок() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	ЗначПоиска = Ключ.ПолучитьЗначение(1, КолонкаПоиска);
	Если (ТипЗначенияСтр(ЗначПоиска) = "СписокЗначений") ИЛИ (ТипЗначенияСтр(ЗначПоиска) = "ТаблицаЗначений") Тогда
		н = 0;
	Иначе
		Если ТЗ.НайтиЗначение(ЗначПоиска, н, КолонкаПоиска)=0 Тогда
			Возврат 0;
		КонецЕсли;
	КонецЕсли;
	
	Если н<НачСтрока Тогда н = НачСтрока; КонецЕсли;
	
	Пока н<=ТЗ.КоличествоСтрок() Цикл
		Найдено = 1;
		Для нк = 1 По Ключ.РазмерСписка() Цикл
			ЗначПоиска = Ключ.ПолучитьЗначение(нк, КолонкаПоиска);
			ЗначТЗ = ТЗ.ПолучитьЗначение(н, КолонкаПоиска);
			Если (ТипЗначенияСтр(ЗначПоиска) = "СписокЗначений") ИЛИ (ТипЗначенияСтр(ЗначПоиска) = "ТаблицаЗначений") Тогда
				//Ищем в списке
				Если ЗначПоиска.НайтиЗначение(ЗначТЗ) = 0 Тогда
					Найдено = 0;
					Прервать;
				КонецЕсли;
			Иначе
				Попытка //Типы могут не совпадать - тогда возникнет исключение
					Если ЗначТЗ <> ЗначПоиска Тогда
						Найдено = 0;
						Прервать;
					КонецЕсли;
				Исключение
					Найдено = 0;
					Прервать;
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;

		Если Найдено=1 Тогда
			Если Позиционироваться = 1 Тогда
				ТЗ.ПолучитьСтрокуПоНомеру(н);
				Возврат 1;
			Иначе
				Возврат н;
			КонецЕсли;
		КонецЕсли;
		н = н + 1;
	КонецЦикла;
	
	Возврат 0;
КонецФункции

//_____________________________________________________________________________
Функция ЗначениеДляСравнения(Значение, ПоВнутрПредставлению)
	Если ПоВнутрПредставлению = 1 Тогда
		Возврат ЗначениеВСтрокуВнутр(Значение);
	Иначе
		Если ТипЗначения(Значение) = 12 Тогда
			Возврат Значение.ПолучитьПозицию();
		КонецЕсли;
		Возврат Строка(Значение);
	КонецЕсли;
КонецФункции

//_____________________________________________________________________________
//Возвращает число:
// 0 - ЗначениеКлюча = ЗначениеТЗ
// 1 - ЗначениеКлюча > ЗначениеТЗ
// -1 - ЗначениеКлюча < ЗначениеТЗ
Функция СравнитьСКлючом(Ключ, ТЗ, НомерСтроки, ПоВнутрПредставлению = 0)
	Перем нк, ИмяКолонки, ЗначениеКлюча, ЗначениеТЗ;
	
	Для нк = 1 По Ключ.РазмерСписка() Цикл
		ЗначениеКлюча = Ключ.ПолучитьЗначение(нк, ИмяКолонки);
		ЗначениеТЗ    = ТЗ.ПолучитьЗначение(НомерСтроки, ИмяКолонки);
		Если ТипЗначения(ЗначениеКлюча) > 3 Тогда
			ЗначениеКлюча = ЗначениеДляСравнения(ЗначениеКлюча, ПоВнутрПредставлению);
			ЗначениеТЗ    = ЗначениеДляСравнения(ЗначениеТЗ,    ПоВнутрПредставлению);
		КонецЕсли;
		Если ЗначениеКлюча > ЗначениеТЗ Тогда
			Возврат 1;
		ИначеЕсли ЗначениеКлюча < ЗначениеТЗ Тогда
			Возврат -1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
КонецФункции

//Бинарный поиск по ключу. ТЗ должна быть предварительно отсортирована по колонкам ключа
//Метод имеет смысл применять, когда первая колонка ключа имеет много одинаковых значений, 
//или когда ключ очень сильно составной
Функция НайтиПоКлючу2(Ключ, ПоВнутрПредставлению, НачСтрока, КонСтрока, ИскатьПоследнюю, Позиционироваться) Экспорт
	Перем ТЗ;
    Перем н1, н, н2;
	Перем Рез, Найдено;
    
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Если ТЗ.КоличествоСтрок() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	Если НачСтрока = 0 Тогда
		н1 = 1;
	Иначе
		н1 = НачСтрока;
	КонецЕсли;
	Если КонСтрока = 0 Тогда
		н2 = ТЗ.КоличествоСтрок();
	Иначе
		н2 = КонСтрока;
	КонецЕсли;
	Найдено = 0;
	
	Пока н1 < н2 Цикл
		н = Цел((н1+н2) / 2);
		Если ИскатьПоследнюю = 1 Тогда
			н = мин(н + 1, н2);
		КонецЕсли;
		
		Рез = СравнитьСКлючом(Ключ, ТЗ, н, ПоВнутрПредставлению);
		Если Рез = 0 Тогда
			Если ИскатьПоследнюю = 0 Тогда
				н2 = н;
			Иначе
				н1 = н
			КонецЕсли;
			Найдено = 1;
		ИначеЕсли Рез < 0 Тогда
			н2 = н - 1;
			КонСтрока = н2;
		Иначе
			н1 = н + 1;
			НачСтрока = н1;
		КонецЕсли;
	КонецЦикла;
	
	Если Найдено = 0 Тогда
		Если СравнитьСКлючом(Ключ, ТЗ, н1, ПоВнутрПредставлению) = 0 Тогда
			Найдено = 1;
		КонецЕсли;
	КонецЕсли;
	
	Если Найдено = 1 Тогда
		Если Позиционироваться  = 1 Тогда
			ТЗ.ПолучитьСтрокуПоНомеру(н1);
			Возврат 1;
		КонецЕсли;
		Возврат н1;
	Иначе
		Возврат 0;
	КонецЕсли;
КонецФункции

//_____________________________________________________________________________
Функция Ключ() Экспорт
	Перем СпПарам, н;
	Перем Ключ, КолонкаПоиска, ЗначПоиска;
	
	СпПарам = Конт(Контекст).ПолучитьСписокПараметров("Ключ");
	Ключ = СоздатьОбъект("СписокЗначений");
	н = 1;
	Пока ПараметрыИзСписка(СпПарам, н, 2, КолонкаПоиска, ЗначПоиска) = 1 Цикл
		Ключ.ДобавитьЗначение(ЗначПоиска, КолонкаПоиска);
	КонецЦикла;
	
	Возврат Ключ;
КонецФункции

//_____________________________________________________________________________
Процедура СортироватьПоКлючу(Ключ, ПоВнутрПредставлению = 0) Экспорт
	Перем нк, ИмяКолонки, СтрокаСортировки, Зпт;
    
	СтрокаСортировки = ""; Зпт = "";
	Для нк = 1 По Ключ.РазмерСписка() Цикл
		Ключ.ПолучитьЗначение(нк, ИмяКолонки);
		СтрокаСортировки = СтрокаСортировки + Зпт + ИмяКолонки;
		Зпт = ",";
	КонецЦикла;
	
	Если ПоВнутрПредставлению = 1 Тогда
		СтрокаСортировки = "*" + СтрЗаменить(СтрокаСортировки, ",", ",*");
	КонецЕсли;
	
	Конт(Контекст).Сортировать(СтрокаСортировки, 1);
КонецПроцедуры

//_____________________________________________________________________________
//вспомогательный метод для сортировки
Procedure swap(self, val i1, val i2) Export
	If i1 > i2 Then
		i = i1;
		i1 = i2;
		i2 = i;
	EndIf;
	shift = i2 - i1;
	If shift > 1 Then
		self.MoveLine(shift-1, i1);
	EndIf;
	self.MoveLine(-shift, i2);
EndProcedure

//_____________________________________________________________________________
Procedure ShortSort(self, lo, hi, CompMod)
    Var p, _max_;

    ///* Note: in assertions below, i and j are alway inside original bound of
    //   array to sort. */

    While hi > lo Do
        //* A[i] <= A[j] for i <= j, j > hi */
        _max_ = lo;
		p = lo + 1;
		While p <= hi Do
            //* A[i] <= A[max] for lo <= i < p */
            If CompMod.Compare(self, p, _max_) > 0 Then
                _max_ = p;
            EndIf;
            ///* A[i] <= A[max] for lo <= i <= p */
			
			p = p + 1;
		EndDo;

        //* A[i] <= A[max] for lo <= i <= hi */

        swap(self, _max_, hi);
		//Сообщить("swap("+_max_+", "+hi+")");

        //* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi = hi - 1;

        //* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    EndDo;
    ///* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
    //   so array is sorted */
EndProcedure

//_____________________________________________________________________________
//Данный метод является практически полной калькой с функции qsort из Standard C Library
//CompMod - объект типа ВыполняемыйМодуль, в котором задана функция сравнения двух строк ТЗ. 
//Ф-ция должна называться Compare, и иметь 3 параметра:
//   - ТЗ - таблица значений, строки которой сравниваются
//   - н1, н2 - Число, номера сравниваемых строк
//Ф-ция должна возвращать 0, если строки равны; -1 если строка н1 меньше строки н2; 1 если строка н1 больше строки н2
Процедура qsort(CompMod) Экспорт
	Var lo, hi; //ends of sub-array currently sorting
	Var m;    //points to middle of subarray
	Var loguy, higuy; //traveling pointers for partition step
	Var size; //size of the sub-array
	Var lostk[30], histk[30];
	Var stkptr;  //* stack for saving sub-array to be processed */
	
	//* Note: the number of stack entries required is no more than
	//   1 + log2(size), so 30 is sufficient for any array */
	
	//if (num < 2 || width == 0)
	//    return;                 /* nothing to do */
	
	self = Конт(Контекст);
	stkptr = 1;                 //* initialize stack */
	lo = 1;
	hi = self.LinesCnt();        ///* initialize limits */
	
	//* this entry point is for pseudo-recursion calling: setting
	//   lo and hi and jumping to here is like recursion, but stkptr is
	//   prserved, locals aren't, so we preserve stuff on the stack */
~recurse:
	
	size = hi - lo + 1;        //* number of el's to sort */
	
	//* below a certain size, it is faster to use a O(n^2) sorting method */
	If size <= 8 Then
		//Сообщить("ShortSort("+lo+", "+hi+")");
		ShortSort(self, lo, hi, CompMod);
	Else
		//First we pick a partititioning element.  The efficiency of the
		//algorithm demands that we find one that is approximately the
		//median of the values, but also that we select one fast.  Using
		//the first one produces bad performace if the array is already
		//sorted, so we use the middle one, which would require a very
		//wierdly arranged array for worst case performance.  Testing shows
		//that a median-of-three algorithm does not, in general, increase
		//performance. */
		
		m = int(lo + (size / 2));      //* find middle element */
		swap(self, m, lo);               //* swap it to beginning of array */
		
		///* We now wish to partition the array into three pieces, one
		//   consisiting of elements <= partition element, one of elements
		//   equal to the parition element, and one of element >= to it.  This
		//   is done below; comments indicate conditions established at every
		//   step. */
		
		loguy = lo;
		higuy = hi + 1;
		
		///* Note that higuy decreases and loguy increases on every iteration,
		//   so loop must terminate. */
		While 1 = 1 Do
			///* lo <= loguy < hi, lo < higuy <= hi + 1,
			//   A[i] <= A[lo] for lo <= i <= loguy,
			//   A[i] >= A[lo] for higuy <= i <= hi */
			
			While 1 = 1 Do
				loguy = loguy + 1;
				If loguy > hi Then
					break;
				EndIf;
				comp = CompMod.Compare(self, loguy, lo);
				If comp > 0 Then
					break;
				EndIf;
			EndDo;
			
			///* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
			//   either loguy > hi or A[loguy] > A[lo] */
			
			While 1 = 1 Do
				higuy = higuy - 1;
				If higuy <= lo Then
					break;
				ElsIf CompMod.Compare(self, higuy, lo) < 0 Then
					break;
				EndIf;
				//If  } while (higuy > lo && comp(higuy, lo) >= 0);
			EndDo;
			
			///* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
			//   either higuy <= lo or A[higuy] < A[lo] */
			
			If higuy < loguy Then break; EndIf;
			
			///* if loguy > hi or higuy <= lo, then we would have exited, so
			//   A[loguy] > A[lo], A[higuy] < A[lo],
			//   loguy < hi, highy > lo */
			
			swap(self, loguy, higuy);
			
			///* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
			//   of loop is re-established */
		EndDo;
		
		///*     A[i] >= A[lo] for higuy < i <= hi,
		//       A[i] <= A[lo] for lo <= i < loguy,
		//       higuy < loguy, lo <= higuy <= hi
		//   implying:
		//       A[i] >= A[lo] for loguy <= i <= hi,
		//       A[i] <= A[lo] for lo <= i <= higuy,
		//       A[i] = A[lo] for higuy < i < loguy */
		
		swap(self, lo, higuy);     //* put partition element in place */
		
		///* OK, now we have the following:
		//      A[i] >= A[higuy] for loguy <= i <= hi,
		//      A[i] <= A[higuy] for lo <= i < higuy
		//      A[i] = A[lo] for higuy <= i < loguy    */
		
		///* We've finished the partition, now we want to sort the subarrays
		//   [lo, higuy-1] and [loguy, hi].
		//   We do the smaller one first to minimize stack usage.
		//   We only sort arrays of length 2 or more.*/
		
		If (higuy - 1 - lo) >= (hi - loguy) Then
			If (lo + 1) < higuy Then
				lostk[stkptr] = lo;
				histk[stkptr] = higuy - 1;
				stkptr = stkptr + 1;
			EndIf;                           //* save big recursion for later */
			
			If loguy < hi Then
				lo = loguy;
				goto ~recurse;           //* do small recursion */
			EndIf;
		Else
			If loguy < hi Then
				lostk[stkptr] = loguy;
				histk[stkptr] = hi;
				stkptr = stkptr + 1;               //* save big recursion for later */
			EndIf;
			
			If (lo + 1) < higuy Then
				hi = higuy - 1;
				goto ~recurse;           //* do small recursion */
			EndIf;
		EndIf;
	EndIf;
	
	///* We have sorted the array, except for any pending sorts on the stack.
	//   Check if there are any, and do them. */
	
	stkptr = stkptr - 1;
	If stkptr > 0 Then
		lo = lostk[stkptr];
		hi = histk[stkptr];
		goto ~recurse;           //* pop subarray from stack */
	Else
		return;                 //* all subarrays done */
	EndIf;
КонецПроцедуры

//_____________________________________________________________________________
//Находит строку ТЗ по указанным колонкам и их значениям
//Возвращает 1 если строка найдена, и 0 в противном случае
Функция НайтиСтроку(КолонкаПоиска, ЗначПоиска, Позиционироваться=1) Экспорт
	Перем ТЗ, н;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Если ТЗ.НайтиЗначение(ЗначПоиска, н, КолонкаПоиска) = 0 Тогда Возврат 0; КонецЕсли;
	Если Позиционироваться = 1 Тогда
		ТЗ.ПолучитьСтрокуПоНомеру(н);
		Возврат 1;
	Иначе
		Возврат н;
	КонецЕсли;
КонецФункции


//_____________________________________________________________________________
//Находит строку по условию <КолонкаПоиска> = <ЗначПоиска>, и возвращает значение колонки <ВозвращаемаяКолонка>
//<КолонкаПоиска> может быть списком значений - тогда поиск идет по нескольким колонкам (параметр <ЗначПоиска> игнорируется)
//Если строка не найдена, то возвращает пустое значение того же типа, что и
//колонка <ВозвращаемаяКолонка>
Функция НайтиИПолучить(КолонкаПоиска, ЗначПоиска, ВозвращаемаяКолонка) Экспорт
    Перем Конт, ТЗ;
	Перем н, Тип, Найдено;
	
	Конт = Конт(Контекст);
	ТЗ = Конт.ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Если ТипЗначенияСтр(КолонкаПоиска)="СписокЗначений" Тогда
		Найдено = Конт.НайтиПоКлючу(0, КолонкаПоиска);
	Иначе
		Найдено = ТЗ.НайтиЗначение(ЗначПоиска, н, КолонкаПоиска);
		Если Найдено = 1 Тогда Найдено = н; КонецЕсли;
	КонецЕсли;

	Если Найдено > 0 Тогда
		Возврат ТЗ.ПолучитьЗначение(н, ВозвращаемаяКолонка);
	Иначе
		ТЗ.ПолучитьПараметрыКолонки(ВозвращаемаяКолонка, Тип);
		Возврат ПолучитьПустоеЗначение(Тип);
	КонецЕсли;
КонецФункции


//_____________________________________________________________________________
// - Колонка: имя колонки, значения которой нужно анализировать
// - ТипПоиска: 1 - искать такое же, 2 - искать отличное, 3 - искать пустое, 4 - искать не пустое
// - Направление: 1 - вниз, -1 - вверх
Функция СледующееЗначение(Знач Колонка, ТипПоиска=1, Направление=1) Экспорт
	Перем ТЗ;
	Перем ТекЗнач, З, н, Найдено;
	
	ТЗ = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");

	Если ТЗ.НомерСтроки = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Если ПустаяСтрока(Колонка) = 1 Тогда
		Попытка
			Колонка = ТЗ.ТекущаяКолонка();
		Исключение
			Возврат 0;
		КонецПопытки;
	КонецЕсли;
	
	ТекЗнач = ТЗ.ПолучитьЗначение(ТЗ.НомерСтроки, Колонка);
	Найдено = 0;
	
	н = ТЗ.НомерСтроки;
	Продолжать = 1;
	
	Пока Продолжать = 1 Цикл
		н = н + Направление;
		Если Направление>0 Тогда
			Продолжать = ?(н <= ТЗ.КоличествоСтрок(), 1, 0);
		Иначе
			Продолжать = ?(н > 0, 1, 0);
		КонецЕсли;
		Если Продолжать=0 Тогда Прервать; КонецЕсли;

		З = ТЗ.ПолучитьЗначение(н, Колонка);
		Если ТипПоиска = 2 Тогда
			Попытка
				Если ТекЗнач <> З Тогда
					Найдено = н;
					Прервать;
				КонецЕсли;
			Исключение
				Найдено = н;
				Прервать;
			КонецПопытки;
		ИначеЕсли ТипПоиска = 3 Тогда
			Если ПустоеЗначение(З) = 1 Тогда
				Найдено = н;
				Прервать;
			КонецЕсли;
		ИначеЕсли ТипПоиска = 4 Тогда
			Если ПустоеЗначение(З) = 0 Тогда
				Найдено = н;
				Прервать;
			КонецЕсли;
		Иначе
			Попытка
				Если ТекЗнач = З Тогда
					Найдено = н;
					Прервать;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	
	Если Найдено = 0 Тогда Возврат 0; КонецЕсли;

	ТЗ.ПолучитьСтрокуПоНомеру(Найдено);
	Попытка
		ТЗ.ТекущаяСтрока(Найдено);
	Исключение
	КонецПопытки;
	
	Возврат Найдено;
КонецФункции


//_____________________________________________________________________________
Процедура СуммироватьСтрокиТЗ(Приемник, н1, Слагаемое, н2, Колонки)
	Перем нк, Имя, Зн1, Зн2;
	Для нк=1 По Колонки.РазмерСписка() Цикл
		Имя = Колонки.ПолучитьЗначение(нк);
		Зн1 = Приемник.ПолучитьЗначение(н1, Имя);
		Зн2 = Слагаемое.ПолучитьЗначение(н2, Имя);
		Приемник.УстановитьЗначение(н1, Имя, Зн1 + Зн2);
	КонецЦикла;
КонецПроцедуры

//_____________________________________________________________________________
//Построчное суммирование ТЗ: Приемник = Приемник + Слагаемое
//Суммируются только числовые колонки. Если колонки из <Слагаемое> отсутствуют в 
//ТЗ <Приемник>, то они добавляются.
//Способ - способ суммирования: 0 - все строки; 1 - только текущие строки;
//         2 - все строки Слагаемого в текущую строку Приемника
//Колонки - строка или список значений с суммируемыми колонками (если это строка,
//          то колонки перечисляются через запятую)
Процедура Суммировать(Слагаемое, Способ=0, _Колонки_="") Экспорт
	Перем Конт, Приемник;
	Перем Колонки, нк, Имя, ТипС, ТипП, Длина, Точность, Заголовок, Ширина, _Формат_, Положение;
	Перем нс, Зн1, Зн2;
	
	Конт = Конт(Контекст);
	Приемник = Конт.ПолучитьБазовыйКласс("ТаблицаЗначений");
	
	Колонки = СоздатьОбъект("СписокЗначений");
	Если ПустоеЗначение(_Колонки_)=0 Тогда
		Если ТипЗначения(_Колонки_)=2 Тогда
			Методы = СоздатьОбъект("ОбщиеМетоды");
			Колонки = Методы.СтрокуВСписок(_Колонки_, ",");
		ИначеЕсли ТипЗначенияСтр(_Колонки_)="СписокЗначений" Тогда
			_Колонки_.Выгрузить(Колонки);
		КонецЕсли;
	КонецЕсли;

	Если Колонки.РазмерСписка()=0 Тогда
		//Формируем список числовых колонок
		Для нк=1 По Слагаемое.КоличествоКолонок() Цикл
			Имя = Слагаемое.ПолучитьПараметрыКолонки(нк, ТипС);
			Если ТипС<>"Число" Тогда Продолжить; КонецЕсли;
			Колонки.ДобавитьЗначение(Имя);
		КонецЦикла;
	КонецЕсли;
	
	//Создаем колонки в приемнике
	нк = Колонки.РазмерСписка();
	Для нк = 1 По Колонки.РазмерСписка() Цикл
		Имя = Колонки.ПолучитьЗначение(нк);
		Если Конт.ЕстьКолонка(Имя) = 0 Тогда
			Слагаемое.ПолучитьПараметрыКолонки(Имя, ТипС, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
			Приемник.НоваяКолонка(Имя, ТипС, Длина, Точность, Заголовок, Ширина, _Формат_, Положение);
		КонецЕсли;
	КонецЦикла;
    
	//Суммируем
	Если Способ = 0 Тогда
		Для нс=1 По Слагаемое.КоличествоСтрок() Цикл
			Если нс > Приемник.КоличествоСтрок() Тогда Приемник.НоваяСтрока(); КонецЕсли;
			СуммироватьСтрокиТЗ(Приемник, нс, Слагаемое, нс, Колонки);
		КонецЦикла;
		
	ИначеЕсли Способ = 1 Тогда
		СуммироватьСтрокиТЗ(Приемник, Приемник.НомерСтроки, Слагаемое, Слагаемое.НомерСтроки, Колонки);
		
	ИначеЕсли Способ=2 Тогда
		Для нс=1 По Слагаемое.КоличествоСтрок() Цикл
			СуммироватьСтрокиТЗ(Приемник, Приемник.НомерСтроки, Слагаемое, нс, Колонки);
		КонецЦикла;
		
	КонецЕсли;
КонецПроцедуры

//_____________________________________________________________________________
Функция ИтогПоСтроке(Знач НомерСтроки="", Знач Колонки="") Экспорт
	Перем Конт, ТЗ;
	Перем Сумма, н, ИмяКолонки, ТипКолонки;
	Перем Знак;
	
	Конт = Конт(Контекст);
	ТЗ = Конт.ПолучитьБазовыйКласс("ТаблицаЗначений");

	Если ТипЗначения(НомерСтроки) <> 1 Тогда //Если НомерСтроки не число, то берём текущую
		НомерСтроки = ТЗ.НомерСтроки;
	КонецЕсли;
		
	Если ТипЗначенияСтр(Колонки)="СписокЗначений" Тогда
	ИначеЕсли ТипЗначенияСтр(Колонки)="Строка" Тогда
		Методы = СоздатьОбъект("ОбщиеМетоды");
		Колонки = СтрЗаменить(Колонки, " ", "");
		Колонки = Методы.СтрокуВСписок(Колонки, ",");
		//Учтем знаки
		Для н = 1 По Колонки.РазмерСписка() Цикл
			ИмяКолонки = Колонки.ПолучитьЗначение(н);
			Если Лев(ИмяКолонки, 1) = "-" Тогда
				ИмяКолонки = Сред(ИмяКолонки, 2);
				Колонки.УстановитьЗначение(н, ИмяКолонки, "-");
			КонецЕсли;
		КонецЦикла;
	Иначе
		Колонки = СоздатьОбъект("СписокЗначений");
		Для нк=1 По ТЗ.КоличествоКолонок() Цикл
			ИмяКолонки = ТЗ.ПолучитьПараметрыКолонки(нк, ТипКолонки);
			Если ТипКолонки <> "Число" Тогда Продолжить; КонецЕсли;
			Колонки.ДобавитьЗначение(ИмяКолонки);
		КонецЦикла;
	КонецЕсли;
	
	Если Колонки.РазмерСписка() = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Сумма = 0;
	Для н=1 По Колонки.РазмерСписка() Цикл
		ИмяКолонки = Колонки.ПолучитьЗначение(н, Знак);
		Знак = ?(Знак = "-", -1, 1);
		
		Если НомерСтроки = 0 Тогда
			//Итог по всем строкам
			Сумма = (ТЗ.Итог(ИмяКолонки) * Знак) + Сумма;
		Иначе
			Значение = ТЗ.ПолучитьЗначение(НомерСтроки, ИмяКолонки);
			Попытка
				Значение = Число(Значение) * Знак;
			Исключение
				Значение = 0;
			КонецПопытки;
			Сумма = Сумма + Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат Сумма;
КонецФункции




//==============================================================================
//----------   Выгрузка ТЗ в Excel  --------------------------------------------
//==============================================================================
Procedure ExportRowToExcel(VT, VT_Row, Sh, Row, ColList)
	Var i, ColID, Value;
	
	For i=1 To ColList.GetListSize() Do
		ColID = ColList.GetValue(i);
		Value = VT.GetValue(VT_Row, ColID);
		If ValueType(Value)>3 Then
			Value = String(Value);
		EndIf;
		If ValueType(Value)=2 Then
			Sh.Cells(Row, i).NumberFormat = "@";
		EndIf;
		Sh.Cells(Row, i).Value = Value;
	EndDo;
EndProcedure


Function ExportToExcel(val Excel, val ColList, val FirstRow, val LastRow, val ToFreezePanes, val AutoFilter) Export
	Var ToUnloadExcel, ColTitle;
	
	VT = Конт(Контекст).ПолучитьБазовыйКласс("ТаблицаЗначений");
	Методы = СоздатьОбъект("ОбщиеМетоды");

	//Подготовка параметров
	If EmptyValue(ColList) = 1 Then
		ColList = CreateObject("СписокЗначений");
		For i=1 To VT.ColumnCount() Do
			ColList.AddValue(VT.GetColumnParameters(i));
		EndDo;
	ElsIf ValueTypeStr(ColList) = "Строка" Then
		ColList = Методы.СтрокуВСписок(ColList, ",");
	EndIf;
	
	If ValueTypeStr(FirstRow) = "Строка" Then
		FirstRow = Методы.СтрокуВСписок(FirstRow);
	ElsIf ValueTypeStr(FirstRow) <> "СписокЗначений" Then
		If FirstRow = 0 Then FirstRow = 1;            EndIf;
		If LastRow = 0  Then LastRow = VT.LinesCnt(); EndIf;
	EndIf;
	
	
	//Создание OLE-объекта Excel, Excel.WorkBook and Excel.Worksheet
	ToUnloadExcel = 1;
	If EmptyValue(Excel) = 1 Then
		Excel = CreateObject("Excel.Application");
		ToUnloadExcel = 0;
	EndIf;

	WB = Excel.Workbooks.Add();
	Sh = WB.ActiveSheet();
	Sh.Visible = 1;
	
	
	//Вывод заголовков
	For i=1 To ColList.GetListSize() Do
		VT.GetColumnParameters(ColList.GetValue(i),,,, ColTitle);
		Sh.Cells(1, i).Value = ColTitle;
	EndDo;
	
	//Вывод таблицы на лист Excel
	Row = 2;
	If ValueTypeStr(FirstRow) = "СписокЗначений" Then
		For Row_i = 1 To FirstRow.GetListSize() Do
			Status("Writing  "+Row_i+"/"+FirstRow.GetListSize());
			
			VT_Row = Number(FirstRow.GetValue(Row_i));
			ExportRowToExcel(VT, VT_Row, Sh, Row, ColList);
			
			Row = Row + 1;
		EndDo;
	Else
		For VT_Row = FirstRow To LastRow Do
			If (VT_Row%10) = 0 Then
				Status("Writing  "+VT_Row+"/"+VT.LinesCnt());
			EndIf;
			
			ExportRowToExcel(VT, VT_Row, Sh, Row, ColList);
			
			Row = Row + 1;
		EndDo;
	EndIf;

	Sh.Cells(2,1).Select();
	//Автоподбор ширины
	For i=1 To ColList.GetListSize() Do
		Sh.Columns(i).EntireColumn.AutoFit();
	EndDo;
	
	If AutoFilter = 1 Then
		Sh.Cells(1,1).AutoFilter();
	EndIf;
	If ToFreezePanes = 1 Then
		Excel.ActiveWindow.FreezePanes = 1;
	EndIf;
	
	WB = "";
	Sh = "";
	Excel.Visible = 1;
	If ToUnloadExcel = 1 Then
		Excel = "";
	EndIf;
	

	Return 1;
EndFunction


//=============================================================================
//=====  Функция записи/чтения ТЗ в файл/из файла  ============================
//=============================================================================
//_____________________________________________________________________________
Процедура ЗаписатьСтрокуВФайл(Файл, Стр, НомерСтроки)
	Перем лСтр;
	
	лСтр = СтрЗаменить(Стр, "\", "\\");
	лСтр = СтрЗаменить(лСтр, РазделительСтрок, "\n");
	
	Если ТипЗначенияСтр(Файл)="Текст" Тогда
		Файл.ДобавитьСтроку(лСтр);
	Иначе
		Файл.ЗаписатьСтроку(лСтр);
	КонецЕсли;
	НомерСтроки = НомерСтроки + 1;
	
	Если (НомерСтроки%100) = 0 Тогда
		Состояние("Запись строки "+НомерСтроки);
	КонецЕсли;
КонецПроцедуры

//_____________________________________________________________________________
Процедура ЗаписатьЗначениеВФайл(Файл, Значение, Прогресс)
	Перем Тип, стрТип;
	Тип = ТипЗначения(Значение);
	стрТип = ТипЗначенияСтр(Значение);
	Если Тип=1 Тогда
		ЗаписатьСтрокуВФайл(Файл, "Ч,"+Значение, Прогресс);
	ИначеЕсли Тип=2 Тогда
		ЗаписатьСтрокуВФайл(Файл, "С,"+Значение, Прогресс);
	ИначеЕсли Тип=3 Тогда
		ЗаписатьСтрокуВФайл(Файл, "Д,"+Формат(Значение, "ДДДММГГГГ"), Прогресс);
	ИначеЕсли (Тип>=10) И (Тип<=15) Тогда
		ЗаписатьСтрокуВФайл(Файл, "Агр,"+ЗначениеВСтроку(Значение), Прогресс);
	ИначеЕсли (стрТип = "ТаблицаЗначений") ИЛИ (стрТип = "Общие.ТаблицаЗначений") Тогда
		ЗаписатьТЗВФайлРекурсия(Значение, Файл, Прогресс);
	ИначеЕсли стрТип = "СписокЗначений" Тогда
		ЗаписатьТЗВФайлРекурсия(Значение, Файл, Прогресс);
	ИначеЕсли стрТип = "DynaValue" Тогда
		ЗаписатьТЗВФайлРекурсия(Значение, Файл, Прогресс);
	Иначе
		ЗаписатьСтрокуВФайл(Файл, ","+ЗначениеВСтроку(Значение), Прогресс);
	КонецЕсли;
КонецПроцедуры

//_____________________________________________________________________________
Процедура ЗаписатьТЗВФайлРекурсия(ТЗ, Файл, Прогресс=1)
	Перем Стр;
	Перем ИмяКолонки, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение;
	Перем Значение, НСтр, НКол;
	
	ТипТЗ = ТипЗначенияСтр(ТЗ);

	//Заголовок
	Если (ТипТЗ = "ТаблицаЗначений") ИЛИ (ТипТЗ = "Общие.ТаблицаЗначений") Тогда
		Если ТипТЗ = "Общие.ТаблицаЗначений" Тогда
			ИД = "{ОТЗ";
		Иначе
			ИД = "{ТЗ";
		КонецЕсли;
		ЗаписатьСтрокуВФайл(Файл, ИД+","+ТЗ.КоличествоКолонок()+","+ТЗ.КоличествоСтрок(), Прогресс);
		Для н=1 По ТЗ.КоличествоКолонок() Цикл
			ИмяКолонки = ТЗ.ПолучитьПараметрыКолонки(н, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение);
			ЗаписатьСтрокуВФайл(Файл, " "+ИмяКолонки+", "+Тип+","+Длина+","+Точность+","+Ширина+","+Положение+", "+Заголовок+СимволТабуляции+ФорматКолонки, Прогресс);
		КонецЦикла;
	ИначеЕсли ТипЗначенияСтр(ТЗ)="СписокЗначений" Тогда
		ЗаписатьСтрокуВФайл(Файл, "{СЗ,"+ТЗ.РазмерСписка(), Прогресс);
	ИначеЕсли ТипТЗ = "DynaValue" Тогда
		ЗаписатьСтрокуВФайл(Файл, "{DV,"+ТЗ.КоличествоСвойств(), Прогресс);
	КонецЕсли;

	//Содержимое
	Если (ТипЗначенияСтр(ТЗ) = "ТаблицаЗначений") ИЛИ (ТипЗначенияСтр(ТЗ) = "Общие.ТаблицаЗначений") Тогда
		Для НСтр=1 По ТЗ.КоличествоСтрок() Цикл
			Если (Прогресс%100)=0 Тогда
				Состояние("Запись строки "+Прогресс);
			КонецЕсли;
			Для НКол=1 По ТЗ.КоличествоКолонок() Цикл
				Значение = ТЗ.ПолучитьЗначение(НСтр, НКол);
				ЗаписатьЗначениеВФайл(Файл, Значение, Прогресс);
			КонецЦикла;
		КонецЦикла;

	ИначеЕсли ТипЗначенияСтр(ТЗ)="СписокЗначений" Тогда
		Для НСтр=1 По ТЗ.РазмерСписка() Цикл
			Если (Прогресс%100)=0 Тогда
				Состояние("Запись строки "+Прогресс);
			КонецЕсли;
			Значение = ТЗ.ПолучитьЗначение(НСтр, Стр);
			ЗаписатьЗначениеВФайл(Файл, Стр, Прогресс);
			ЗаписатьЗначениеВФайл(Файл, Значение, Прогресс);
		КонецЦикла;

	ИначеЕсли ТипТЗ = "DynaValue" Тогда
		ТЗ.ВыбратьСвойства();
		Пока ТЗ.ПолучитьСвойство(Значение, Стр) = 1 Цикл
			ЗаписатьЗначениеВФайл(Файл, Стр, Прогресс);
			ЗаписатьЗначениеВФайл(Файл, Значение, Прогресс);
		КонецЦикла;
	КонецЕсли;
	
	ЗаписатьСтрокуВФайл(Файл, "}", Прогресс);
КонецПроцедуры


//_____________________________________________________________________________
Функция ПолучитьСтроку(Файл, НомерСтроки)
	Перем Рез, Стр, РезСтр, Поз;
	
	Если ТипЗначенияСтр(Файл)="Текст" Тогда
		Стр = Файл.ПолучитьСтроку(НомерСтроки);
	Иначе
		Рез = Файл.ПрочитатьСтроку(Стр);
		Если Рез=0 Тогда
			Стр = "";
		КонецЕсли;
	КонецЕсли;
	НомерСтроки = НомерСтроки + 1;
	
	Поз = Найти(Стр, "\");
	РезСтр = "";
	Пока Поз > 0 Цикл
		РезСтр = РезСтр + Лев(Стр, Поз - 1);
		Если Сред(Стр, Поз+1, 1) = "\" Тогда      // два слэша трансформируем в один слэш
			РезСтр = РезСтр + "\";
			Стр = Сред(Стр, Поз+2);
		ИначеЕсли Сред(Стр, Поз+1, 1) = "n" Тогда // \n трансформируем в РазделительСтрок
			РезСтр = РезСтр + РазделительСтрок;
			Стр = Сред(Стр, Поз+2);
		Иначе                                     // просто слэш так и оставляем - это старый формат файла
			РезСтр = РезСтр + "\";
			Стр = Сред(Стр, Поз);
		КонецЕсли;
		Поз = Найти(Стр, "\");
	КонецЦикла;
	РезСтр = РезСтр + Стр;
	
	Возврат РезСтр;
КонецФункции

//_____________________________________________________________________________
Функция ЗначИзФайла(Файл, НомерСтроки, _Стр_=0)
	Перем Стр, Поз, Тип, Значение;
	
	Если ТипЗначения(_Стр_)=2 Тогда
		Стр = _Стр_; НомерСтроки = НомерСтроки + 1;
	Иначе
		Стр = ПолучитьСтроку(Файл, НомерСтроки);
	КонецЕсли;
	Если (НомерСтроки%100)=0 Тогда
		Состояние("Считываю строку "+НомерСтроки);
	КонецЕсли;
	
	Поз = Найти(Стр, ",");
	Тип = Лев(Стр, Поз-1);
	Значение = Сред(Стр, Поз+1);
	
	Если Тип = "Ч" Тогда
		Значение = Число(Значение);
	ИначеЕсли Тип = "Д" Тогда
		Значение = Дата(Значение);
	//ИначеЕсли Тип = "С" Тогда
	//	Значение = Строка(Значение);
	ИначеЕсли Тип = "Агр" Тогда
		Значение = ЗначениеИзСтроки(Значение);
	ИначеЕсли Тип = "{ТЗ" Тогда
		НомерСтроки = НомерСтроки - 1;
		Значение = СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки, Стр);
	ИначеЕсли Тип="{ОТЗ" Тогда
		НомерСтроки = НомерСтроки - 1;
		Значение = СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки, Стр);
	ИначеЕсли Тип = "{СЗ" Тогда
		НомерСтроки = НомерСтроки - 1;
		Значение = СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки, Стр);
	ИначеЕсли Тип="{DV" Тогда
		НомерСтроки = НомерСтроки - 1;
		Значение = СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки, Стр);
	ИначеЕсли Тип = "" Тогда
		Значение = ЗначениеИзСтроки(Значение);
	КонецЕсли;
	
	Возврат Значение;
КонецФункции

//_____________________________________________________________________________
Функция СчитатьТЗИзФайлаРекурсия(Файл, НомерСтроки=1, _Стр_=0)
	Перем Стр, Токен;
	Перем ТЗ, ЧислоКолонок, ЧислоСтрок;
	Перем ИмяКолонки, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение;
	Перем НСтр, НКол;
	Перем Значение, СтрЗнач;
	
	//Считываем шапку
	Если ТипЗначения(_Стр_)=2 Тогда
		Стр = _Стр_; НомерСтроки = НомерСтроки + 1;
	Иначе
		Стр = ПолучитьСтроку(Файл, НомерСтроки);
	КонецЕсли;

	Парсер = СоздатьОбъект("Общие.Парсер");
	Парсер.Инициализация(Стр, ",");
	Парсер.ПолучитьТокен(Токен);
	Если (Токен="{ТЗ") ИЛИ (Токен="{ОТЗ") Тогда
		Если (Токен="{ОТЗ") Тогда
			ТЗ = СоздатьОбъект("Общие.ТаблицаЗначений");
		Иначе
			ТЗ = СоздатьОбъект("ТаблицаЗначений");
		КонецЕсли;
		
		Парсер.ПолучитьТокен(Токен); ЧислоКолонок = Число(Токен);
		Парсер.ПолучитьТокен(Токен); ЧислоСтрок = Число(Токен);
		
		//Создаем колонки ТЗ
		Для НКол = 1 По ЧислоКолонок Цикл
			Стр = ПолучитьСтроку(Файл, НомерСтроки);
			Парсер.Инициализация(Стр, ",");
			Парсер.ПолучитьТокен(Токен); Имя = СокрЛП(Токен);
			Парсер.ПолучитьТокен(Токен); Тип = СокрЛП(Токен);
			Парсер.ПолучитьТокен(Токен); Длина = Число(Токен);
			Парсер.ПолучитьТокен(Токен); Точность = Число(Токен);
			Парсер.ПолучитьТокен(Токен); Ширина = Число(Токен);
			Парсер.ПолучитьТокен(Токен); Положение = Число(Токен);
			Парсер.Инициализация(Сред(Парсер.ОстатокСтроки(), 2), СимволТабуляции); //Всё остальное может содержать ",", поэтому разделитель - табуляция.
			Парсер.ПолучитьТокен(Токен); Заголовок = СокрЛ(Токен);
			Парсер.ПолучитьТокен(Токен); ФорматКолонки = СокрЛ(Токен);
			ТЗ.НоваяКолонка(Имя, Тип, Длина, Точность, Заголовок, Ширина, ФорматКолонки, Положение);
		КонецЦикла;
	ИначеЕсли Токен = "{СЗ" Тогда
		ТЗ = СоздатьОбъект("СписокЗначений");
		Парсер.ПолучитьТокен(Токен); ЧислоСтрок = Число(Токен);
	ИначеЕсли Токен = "{DV" Тогда
		ТЗ = СоздатьОбъект("DynaValue");
		Парсер.ПолучитьТокен(Токен); ЧислоСтрок = Число(Токен);
	Иначе
		Сообщить("Неверный формат файла: стр "+НомерСтроки, "!");
		Возврат ТЗ;
	КонецЕсли;
	
	стрТип = ТипЗначенияСтр(ТЗ);
	Если (стрТип="ТаблицаЗначений") ИЛИ (стрТип="Общие.ТаблицаЗначений") Тогда
		//Считываем строки ТЗ
		Для НСтр=1 По ЧислоСтрок Цикл
			ТЗ.НоваяСтрока();
			Для НКол=1 По ЧислоКолонок Цикл
				ТЗ.УстановитьЗначение(НСтр, НКол, ЗначИзФайла(Файл, НомерСтроки));
			КонецЦикла;
		КонецЦикла;
	ИначеЕсли стрТип = "СписокЗначений" Тогда
		Для НСтр=1 По ЧислоСтрок Цикл
			Стр = ЗначИзФайла(Файл, НомерСтроки);
			Если ТипЗначения(Стр)<>2 Тогда
				Сообщить("Неверный формат файла!", "!");
				Возврат ТЗ;
			КонецЕсли;
			Значение = ЗначИзФайла(Файл, НомерСтроки);
			ТЗ.ДобавитьЗначение(Значение, Стр);
		КонецЦикла;

	ИначеЕсли стрТип="DynaValue" Тогда
		Для НСтр=1 По ЧислоСтрок Цикл
			Стр = ЗначИзФайла(Файл, НомерСтроки);
			Если ТипЗначения(Стр)<>2 Тогда
				Сообщить("Неверный формат файла! Ожидалось строковое значение для DynaValue, получили '"+Стр+"' : стр "+НомерСтроки, "!");
				Возврат ТЗ;
			КонецЕсли;
			Значение = ЗначИзФайла(Файл, НомерСтроки);
			ТЗ.ДобавитьСвойство(Стр, Значение);
		КонецЦикла;
	КонецЕсли;
	
	Стр = ПолучитьСтроку(Файл, НомерСтроки);
	Если Стр <> "}" Тогда
		Сообщить("Неверный формат файла", "!");
	КонецЕсли;

	Возврат ТЗ;
КонецФункции


//_____________________________________________________________________________
Функция CreateV7TextFile(ИмяФайла, Режим)
	Если ЗагрузитьВнешнююКомпоненту("v7plus.dll")=0 Тогда
		//Сообщить("Не удалось обнаружить компоненту v7plus.dll!"); 
		Возврат 0;
	КонецЕсли;

	Попытка
		Файл = СоздатьОбъект("AddIn.V7TextFile");
	Исключение 
		Сообщить("Не удалось создать объект Addin.V7TextFile!");
		Возврат 0;
	КонецПопытки; 

	Файл.ОткрытьФайл(ИмяФайла, Режим);
	Возврат Файл;
КонецФункции

//_____________________________________________________________________________
Функция ЗаписатьВФайл(ИмяФайла, ФорматФайла = 3) Экспорт
	Перем ТЗ;
	
	Если ПустоеЗначение(ИмяФайла) = 1 Тогда 
		Возврат 0;
	КонецЕсли;
	
	ТЗ = ТЗ();
	
	Если ФорматФайла = 1 Тогда
		Возврат ЗначениеВФайл(ИмяФайла, ТЗ, 1);
	ИначеЕсли ФорматФайла = 2 Тогда
		Возврат ЗначениеВФайл(ИмяФайла, ТЗ, 2);
	Иначе
		Файл = CreateV7TextFile(ИмяФайла, 1);
		Если ПустоеЗначение(Файл) = 1 Тогда
			Файл = СоздатьОбъект("Текст");
		КонецЕсли;
		
		ЗаписатьТЗВФайлРекурсия(ТЗ, Файл);
		
		Если ТипЗначенияСтр(Файл) = "Текст" Тогда
			Файл.Записать(ИмяФайла);
		Иначе
			Файл.ЗакрытьФайл();
		КонецЕсли;
		Возврат 1;
	КонецЕсли;
КонецФункции

//_____________________________________________________________________________
Функция СчитатьИзФайла(ИмяФайла, ФорматФайла = 0) Экспорт
	Перем ТЗ, Файл;
	
	Если ПустоеЗначение(ИмяФайла)=1 Тогда 
		Возврат 0;
	КонецЕсли;


	Если ФорматФайла = 0 Тогда
		Если СчитатьИзФайла(ИмяФайла, 1) = 1 Тогда Возврат 1; КонецЕсли;
		Если СчитатьИзФайла(ИмяФайла, 2) = 1 Тогда Возврат 1; КонецЕсли;
		Если СчитатьИзФайла(ИмяФайла, 3) = 1 Тогда Возврат 1; КонецЕсли;
		Возврат 0;
		
	ИначеЕсли ФорматФайла = 1 Тогда
		Попытка
			ТЗ = ЗначениеИзФайла(ИмяФайла,, 1);
		Исключение
		КонецПопытки;
	ИначеЕсли ФорматФайла = 2 Тогда
		Попытка
			ТЗ = ЗначениеИзФайла(ИмяФайла, ТЗ, 2);
		Исключение
		КонецПопытки;
	Иначе
		Файл = CreateV7TextFile(ИмяФайла, 0);
		Если ПустоеЗначение(Файл) = 1 Тогда
			Файл = СоздатьОбъект("Текст");
			Файл.Открыть(ИмяФайла);
		КонецЕсли;
		
		ТЗ = СчитатьТЗИзФайлаРекурсия(Файл);
		
		Если ТипЗначенияСтр(Файл) = "Текст" Тогда
			Файл = "";
		Иначе
			Файл.ЗакрытьФайл();
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗначения(ТЗ) <> 0 Тогда
		Попытка
			Загрузить(ТЗ);
		Исключение
			Возврат 0;
		КонецПопытки;
	Иначе
		Возврат 0;
	КонецЕсли;

	Возврат 1;
КонецФункции
